React - Review
- 자바스크립트 라이브러리, 메타(구 페이스북)
    => 프론트 프레임워크로도 불림
    => Vue, Angular, Svelt


- SPA(Single Page Application -> index.html 1개) : 강제사항은 아님!
    => 상황에 따라 몇개의 페이지를 나누어도 상관없음!


- 프로젝트 생성
    => 바닥부터 하지 않음 (필요한 라이브러리와 세팅이 많아서....)
    => Scafolding, boiler-plate, template 코드라고 불리는 곳에서 시작
    => Create-React-App (지금은 사용하지 않음, 심지어 페이스북에서도 안씀..)
    => Vite(Vue 만든 사람이 만든거) ---> 이걸 주로 사용!

    [ `npm create vite@latest . ` ] OR [ `npx create-vite@latest . `  ] 입력하기
        => npx : 굳이 설치 안하고 하겠다! 그대로 복붙하겠다! 

    [ npm i ] 입력 
        => 필요한 라이브러리 설치 'node_modules' 폴더 생성
    
    [ npm run dev ]
        => 개발 서버 실행
    
    [ 폴더 및 파일 정리 후 작업 시작 ]
        => 필요없는 것들이 들어있음


- 컴포넌트 기반 (리액트의 특징, 사실은 거의 모든 프레임워크가 추구하는 방향)
    JSX => 진짜 html 아니다
            {
                "h1",
                "children" : [요소들]
            }

    => 컴포넌트 제작 시 기존 html에서 필요한 부분만 훔쳐오기(아는거 가져오기)
        컴포넌트 라이브러리를 검색 활용해서 가져오기(문서를 읽어야함)
        복잡한 컴포넌트 TOP    -> DOWN 방식
        간단한 컴포넌트 Bottom -> Up 방식


- React 는 가상DOM 덕분에 훨씬 빠르게 느껴진다.
    => 가상DOM(Virtual DOM)은 <<< 가짜HTML이다 >>>를 꼭 기억하자
    => 브라주어의 실제 DOM을 제어하기 전에 메모리상 JSON 형태의 DOM에서 달라진 부분을 찾아서
    다라진 부분만 제어한다.(빠르다!)
    -----추가설명-------------------------------------
    => 실제 브라우저는 실제DOM이다!
    => JSON 파싱해주는 것은 가상DOM이다.
    => 가상DOM에서 테스트를 하고 실제 브라우저에는 메모리상에서 변경된 내용들만 가져다 꽂아준다.
    => 즉, 설계도면을 들고 "00동00호00방으로 가서 고치세요"하는 것과 같다.


- XML과 HTML 차이!
    => HTML < XML (XML의 한 부분이 HTML) 
    => "HTML 문서가 전달되는 것을 보고 전자문서라는 것을 생각해서 나온게 XML = B2B"

- 마커랭기지 (XML에 대한 배경설명)
    => 어떤 표시, 행동을 나타낼 수도 있고, 의미를 부여하는 것일수도 있다.

상태관리(필수)  useState =>  전역변수 관리 , Reactive 변수
                               => 이게 바뀌면 자동으로 Re-Rendering이 일어남!
                               => 어렵당~  낯설당~ 잘 응용해야겠당. 
                               => 원시타입, 객체타입([],{})일때는 새 객체를 주어야 바뀌었다고 인식!

Restful이 뭡니까?
get : 조회
post : 등록(생성)
put : 수정
delete : 삭제
(Front(UI서버) / Back(Data)서버를 분리되서 작업할 때 좋다! 
프론트와 백의 암묵적 약속! URL 합의! 각각 작업이 가능하다!
CSR => SPA => ajax
*** @Controller + @ResponseBody (=잭슨라이브러리동작)
		      + @RequestBode (=잭슨라이브러리동작)
*** @PathVariable


Restful client (same-origin) => fetch-built-in(ajax)로 구현
++ fetch는 폐쇄망에서 사용할 수 있기 때문에 사용법을 알아야한다!
++ axios는 폐쇄망에서 사용불가하기 때문에... 둘다 알아야한다!

// 다르면 뭐가 다른지? 생각하고 느낌을 느껴야 한다!
// 코드 구현 순서가 쪼메 달라짐
// 일반 실제 프로그램 사용자가 이 방식을 좋아함
// 화면 깜빡거림이 없어서 데스크탑 앱처럼 느껴진다(좋앙)
// 백과 프론트의 평화를 위해 URL 약속을 먼저 정해야한다! (혼자 한다면 상관없지만?!)
// URI 와 URL의 차이점 : URL은 URI의 하위 개념 "모든 URL은 URI다."


useState => 확장 => useReducer => 구조분해!!!!!!! 기억하기......
const [상태변수, dispatch] = useReducer(reducer, 초기값);
const [상태변수add, dispatchIdol] = useReducer(addReducer, 초기값);
===========>> 이미 설계가 되어있기 때문에 사용법을 명확히 알면 된다!

useRef "변수 관리(렌더링해도 값이 값이 유지된다!)
속성은 1개 => Current
대표적 사용 케이스 => DOM Element 레퍼런스
일반 전역변수 (리렌더링 발생하지 않음) 선언에도 이걸 사용할 수 있다!

tailwindcss "CSS 계의 게임 체인저!" 
==> 자동완성이된다.....!!!!!!!!!! VSCode에서!
==> 사용하다보면 익숙해진다!

useEffect 를 sideEffect : 비동기 처리 블록을 만들기 위해서
=> 두번째 매개변수
=> 없으면 Re-Rendering 될 때 마다 매번 실행된다.
=> [], 처음 Rendering 될 때만 실행된다.
=> [merong, jihu] 메롱, 지후란 상태변수가 바뀔 때마다 자동 실행된다.


@CrossOrogon("*"), @CrossOrigin({"열어주고 싶은 사이트", "열어주고 싶은 사이트"})

- Origin 구성 3요소 : 프로토콜 + 도메인명(서버명) + 포트
- http://하은.com:8080 3요소 중 1개라도 다르면
그 요청은 CrossOrigin 요청이다. (Same-Origin 정책의 제약을 받는다.)
AJAX 요청일 때만! (왜? 변수에 받기 때문에 조작이 가능하다)
- 뉘앙스를 느끼기 시작해야한다!
- DOMContentLoaded 이벤트나 강제 리렌더링, 상태변수가 바뀌었을 때
- Update(이것도 Re-Rendering 필요)

```
function 소희() {
	비동기 코드
}
소희()
```

==> useState ~ useReducer 	~ useContext
==> useEffect 
==> useRef 잘 쓰면 편하다!
==> props Driling (단방향 전달)
chidren(props에 포함된당
<하은> 요기에 쓰는게 chidren </하은>
<하은/>

context는 이해
context.Provider 를 보통 분리해서 사용(분리패턴)
context, 상태관리 (reducer 도 별도 파일로!
어떤 context가 어떤 내용을 담고 있는지와 그 처리를 같은 파일에 담기 위함

lucide icon
context API => 중앙 상태 관리 (Not Props Drilling )
		 => 상태변수/상태변수 함수,context 가지고 어디서든 필요할 때 useContext

const  하은컨텍스트 = createContext()
하은컨텍스트.Provider value 속성에 하은 컨텍스트에 담을 내용 지정
			       value에 담는건 상태변수, reducer
			       크게 하나로 담을 건지, 별도 context를 추가로 만들어서 나누어 담을건지는 선택!

개발자는 useContext를 잘 쓰면 된다!!
context API => useReducer랑 같이 사용! 
요렇게만 잘 써도 + ajax 하면 거의  90% 이상 문제 없음!!!
자주 사용하는 것은 use를 붙인당, 없는 것은 세팅의 개념!

useContext 다시 정리해봅시당!

Refactoring(리펙토링 : 파일분리되어있는 상태)
=> "정리작업!" 목적은 가독성과 성능! 을 위함
=> 개인적으로 자신의 코드를 리팩토링 할 때 실력이 가장 많이 늘어난다!
"성장한다!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"

// 커스텀 HOOK 사용자가 만드는 HOOK
// 이름은 use 로 시작해야함
// 함수 안에는 제공되는 HOOK이 사용되어야함

Router 라우터
=> 네트워크상의 최단경로를 찾아준다
=> 주소표시줄(라우터) 리액트에서는 제공하지 않음

React-Router 
=> 별도 라이브러리 주소표시줄 처리
=> SPA 에서 처리가 애매한게 1개 있는데, 그건 바로 뒤로가기!
=> 직접 처리하려면 window.history 객체를 이용해야한다 (어렵다..)
	하지만 생각보다 손이 많이 간다! 
	그래서 리액트라우터 사용하면 히스토리 객체를 이용하지 않아도 됨!
=> react에 포함되지 않는 필수 기능이라 별도 라이브러리설치.., 웹에선 필수!!! 
	(일반 사용자들이 이미 즐겨찾기 등에 url을 사용하고 있음.)

NGROK (네트워크 터널링)
=> 트로이목마! 내 PC에 스파이처럼 들어와서 공유기 통해 연결이 아니라 직속연결을 한다!
=> 잘 쓰면 아주 편함! (1개지만 무로 도메인에다가 https 라니~~?)
=> 실제 테스트로 구매해서 사용해도 도메인과 고정IP 구매 비교하면 미치도록 싸당!
=> http + s 
==> "s"에 따라서 브라우저에서 PC에 접근하는 권한이 달라진다!

***** 여러분에게는 미안하지만 라우터 기능은 그냥 숟가락과 젓가락과 같다... 써야한다!
라우터의 대표기능 들도 추가 정리
useSearchParams , useNavigate, useLocation, ...

Router의 설정에는 크게 2가지 (어느게 좋다 말하기는 어렵다!
1) 태그를 이용하는 것<>
<BrowserRoeter> 가장 바깥에 둘러치는 Provider
Routes / Route / Link(서버에 안요청) , a(서버에 요청) / navigate(useNavigate의 리턴)

중첩 Route
404 path = "*" 정의된 처리 빼고 나머지 전부는 404페이지로 넘긴다!
```
<Route>
	중첩된다! 밖이 부모, 안이 자식
	<Route />	=> 이거 있어야 부모 안에서 출력 됨!!!!! <Outlet /> 
</Route>
```
SPA에서는 <Link></Link>태그를 사용하도록 하자
나는 이미 페이지 정보를 모두 제공했음에도
<a>태그 사용했을 때는 계속 새로고침이 일어나서 서버한테 "줘줘!!!줘! 또줘!"하고 있었음.
(단, 외부 사이트 이동은 <a>태그!)

2) json 형식을 이용하는 것

===> 둘 중 하나라도 익숙하게... (회사가면 강제로 결정됨!)


** 면접꿀팁!!!!
네트워크 터널링 이용해서 무료로 제 프로젝트를 올려두었습니다.
제 프로젝트를 구경해보십시오!!!
NGROK 구동시킨 상태로 페이지 설명하는 것도 좋은 방법이다.
이건 바로 나만의 도메인이니까!!!!!



























